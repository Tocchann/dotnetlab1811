# Native アプリと .NET アプリを連動するいくつかの方法

## 参考URL

* <https://github.com/tocchann/dotnetlab1811/>
* [C++/CLI (Visual C++) による .NET プログラミング](https://docs.microsoft.com/ja-jp/cpp/dotnet/dotnet-programming-with-cpp-cli-visual-cpp?view=vs-2017)
  * <https://docs.microsoft.com/ja-jp/cpp/dotnet/>

## アジェンダ

* C++ プログラムと .NET プログラムの連携パターン
* ここだけの話...
* C++ アプリの .NET 対応
* .NET 側の準備
* C++ から、.NET Framework のクラスメソッドを呼び出す。
* MFCのCWinFormsView を使って内部にウィンドウを張り付ける。
* Native アプリと .NET アプリのプロセス間連携を行う。

## C++ プログラムと .NET プログラムの連携パターン

* .exe が .NET Framework 製
  * C++/CLI のDLLを作成する
    * LIBの場合
    * COM 呼び出しのラップ
  * プラットフォーム呼び出し(P/Invoke)する
    * API 呼び出しのようなパターン
  * よくある話なので今日はパス！
* .exe が C++ プログラム製
  * .NET を独自にホスティングする
    * インストールされているランタイムを動的判断してホスト可能
    * 既存環境をいじれないインストーラ専用と思ったほうがいい
  * /clr オプションをつける
    * 既存アプリで、部分的に .NET の機能を利用する場合に使う
    * プロジェクトオプションでターゲットバージョンを指定
    　* VC++14.0(VS2015) から可能
* 互いに別プロセスで呼び出す
  * プロセス間通信(IPC)を使うことで実現
  * 直接送受信できるプロトコルはそれほど多くない
  * 既存プログラムの変更範囲は IPC 機能の追加だけ

## ここだけの話

* デフォルトスレッドモデルはMTA
  * メイン関数が CLI の場合の話
  * COM の多くは、STA前提
* LIB のCLI化はリンク先のプロジェクトをCLIにしないと意味がない
  * CLRオプションはプロジェクトの設定なので使う側も必要
* DLL の初期化の注意点
  * ローダーロック問題に対応が必要
  * めったに発生しないだけでNativeDLLでも起こりえる問題
  * 外部変数はコンストラクタのないものだけにする
* 「空の CLR プロジェクト」から始める
  * 設計を見直しましょう！
  * C++/CLI がなければ配布が少し楽になります！
    * .NET Core に C++/CLI のようなものない！

## C++ アプリの .NET 対応

* 新規に C++/CLI アプリを作りたい！
  * たとえコンソールでもC#を使うことをお勧め。
  * 話題の .NET Core に、C++/CLI 相当はない！
  * C++/CLI は、配布するランタイムが一つ増える
    * VC++ ランタイムは、プリインストールされていない
* 既存の C++ アプリから .NET の機能を使いたい！
  * C++/CLI の機能で普通に使える
    * gcnew NetCls(); で構築が可能！
    * 文字列の受け渡しも昔よりは簡単になった！
  * MFC アプリの場合
    * 子ウィンドウとしてUIを張り付け可能
    * クラスライブラリレベルのサポートがある
  * ATL(WTL) アプリの場合
    * 非UI部分のみサポート(CStringなどなど)

## C++ アプリに .NET の機能を追加しよう

* C++/CLI にプロジェクトを変換する
  * /MD オプションに切り替える
  * 文字コードをUNICODEにする
  * エディットコンティニューをOFFにする
    * ここまではVS2017のデフォルト
  * EXEの /clr スイッチの有効化
  * TargetVersion を指定する

## クラスライブラリの呼び出し

* 通常のコンポーネントとして呼び出し可能
  * メソッド呼び出し、プロパティ呼び出しもそのまま可能



## 画面コンポーネントのサポート

* MFC 側のサポートは3種類
  * CWinFormsView
    * 画面全体にユーザーコントロールを張り付けるような形で利用
  * CWinFormsControl\<TManagedControl>
    * ボタンなどと同じようにコントロールコンポーネントとして部分的に利用
  * CWinFormsDialog\<TManagedControl>
    * ダイアログリソース代わりに利用
* .NET 側は System.Windows.Forms.Control の派生クラスを定義
  * WPF を張り付ける場合、ElementHost 派生クラスを経由する

## DEMO 構成

* CWinFormsView を張り付けた例
* クラスオブジェクトの作成とメソッド・プロパティアクセス
* 名前付きパイプを使ったプロセス間通信
* 文字列データの受け渡し
