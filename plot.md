# Native アプリと .NET アプリを連動するいくつかの方法

## 参考URL

* [C++/CLI (Visual C++) による .NET プログラミング](https://docs.microsoft.com/ja-jp/cpp/dotnet/dotnet-programming-with-cpp-cli-visual-cpp?view=vs-2017)
  * <https://docs.microsoft.com/ja-jp/cpp/dotnet/>

## アジェンダ

* C++ プログラムと .NET プログラムの連携パターン
* ここだけの話...
* C++ アプリの .NET 対応
* .NET 側の準備
* C++ から、.NET Framework のクラスメソッドを呼び出す。
* MFCのCWinFormsView を使って内部にウィンドウを張り付ける。
* Native アプリと .NET アプリのプロセス間連携を行う。

## C++ プログラムと .NET プログラムの連携パターン

* .exe が .NET Framework 製
  * C++/CLI のDLLを作成する
    * LIBの場合
    * COM 呼び出しのラップ
  * プラットフォーム呼び出し(P/Invoke)する
    * API 呼び出しのようなパターン
  * よくある話なので今日はパス！
* .exe が C++ プログラム製
  * .NET を独自にホスティングする
    * インストールされているランタイムを動的判断してホスト可能
    * 既存環境をいじれないインストーラ専用と思ったほうがいい
  * /clr オプションをつける
    * 既存アプリで、部分的に .NET の機能を利用する場合に使う
    * プロジェクトオプションでターゲットバージョンを指定
    　* VC++14.0(VS2015) から可能
* 互いに別プロセスで呼び出す
  * プロセス間通信(IPC)を使うことで実現
  * 直接送受信できるプロトコルはそれほど多くない
  * 既存プログラムの変更範囲は IPC 機能の追加だけ

## ここだけの話

* デフォルトスレッドモデルはMTA
  * メイン関数が CLI の場合の話
  * COM の多くは、STA前提
* LIB のCLI化はリンク先のプロジェクトをCLIにしないと意味がない
  * CLRオプションはプロジェクトの設定なので使う側も必要
* DLL の初期化の注意点
  * ローダーロック問題に対応が必要
  * めったに発生しないだけでNativeDLLでも起こりえる問題
  * 外部変数はコンストラクタのないものだけにする
* 「空の CLR プロジェクト」から始める
  * 設計を見直しましょう！
  * C++/CLI がなければ配布が少し楽になります！
    * .NET Core に C++/CLI のようなものない！

## C++ アプリの .NET 対応

* 新規に C++/CLI アプリを作る？
  * たとえコンソールアプリだったとしても C# で始めましょう。
  * C++/CLI は、ランタイム配布が面倒
    * .NET Framework + VC++ ランタイム
* 既存のC++アプリに .NET の機能を埋め込む。
  * C++/CLI の機能で普通に使える
    * gcnew NetCls(); で構築が可能！
    * 文字列の受け渡しも簡単？＜かもねｗ
  * MFC アプリの場合
    * 子ウィンドウとしてUIを張り付け可能
    * クラスライブラリのサポートがある
  * ATL(WTL) アプリの場合
    * 子ウィンドウとしてUIを張り付ける仕組みがない

## まずは、プロジェクトの設定を変更する

* C++/CLI にプロジェクトを変換する
  * /MD オプションに切り替える
  * 文字コードをUNICODEにする
  * エディットコンティニューをOFFにする
  * EXEの /clr スイッチの有効化
  * TargetVersion を指定する
  * VS2017のデフォルト出力は .NET 関係以外上記設定

## 画面コンポーネントのサポート

* MFC 側のサポートは3種類
  * CWinFormsView
    * 画面全体にユーザーコントロールを張り付けるような形で利用
  * CWinFormsControl\<TManagedControl>
    * ボタンなどと同じようにコントロールコンポーネントとして部分的に利用
  * CWinFormsDialog\<TManagedControl>
    * ダイアログリソース代わりに利用
* .NET 側は System.Windows.Forms.Control の派生クラスを定義
  * WPF を張り付ける場合、ElementHost 派生クラスを経由する

## クラスライブラリの呼び出し

* 通常のコンポーネントとしての呼び出しも可能
  * メソッドとしてモーダルに処理できるもの等に使う
  * 内部にUIがあることを意識せずに使える

## DEMO 構成

* CWinFormsView を張り付けた例
* <./CollabApp/CollabAppView.h>
* クラスライブラリ経由で利用するWPFモーダルダイアログ表示例
* 名前付きパイプを使ったプロセス間通信
* 文字列データのやり取り(受け渡し)

